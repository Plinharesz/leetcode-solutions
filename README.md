# üöÄ Data Structures & Algorithms in Java

![Java](https://img.shields.io/badge/Java-ED8B00?style=for-the-badge&logo=openjdk&logoColor=white)
![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)
![IntelliJ IDEA](https://img.shields.io/badge/IntelliJIDEA-000000?style=for-the-badge&logo=intellij-idea&logoColor=white)

This repository contains my solutions to algorithmic problems from **LeetCode**, following the **NeetCode 150** roadmap. The main goal is to master Data Structures, Algorithms, and problem-solving patterns for technical interviews.

All solutions are implemented in **Java**, with a strong focus on **Code Cleanliness** and **Time/Space Complexity analysis**.

## üìö Study Roadmap & Progress

I am following a structured pattern-based approach. Below is the log of solved problems:

### üü¢ Arrays & Hashing
| Problem | Difficulty | Solution | Pattern | Time Complexity | Space Complexity |
| :--- | :---: | :---: | :--- | :---: | :---: |
| [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) | Easy | [View Code](./src/main/java/arrays_hashing/ContainsDuplicate.java) | HashMap / HashSet | $O(n)$ | $O(n)$ |
| [Valid Anagram](https://leetcode.com/problems/valid-anagram/) | Easy | [View Code](./src/main/java/arrays_hashing/ValidAnagram.java) | Frequency Array / Map | $O(n)$ | $O(1)$ |
| [Two Sum](https://leetcode.com/problems/two-sum/) | Easy | [View Code](./src/main/java/arrays_hashing/TwoSum.java) | HashMap | $O(n)$ | $O(n)$ |

*(More patterns like Two Pointers, Sliding Window, and Stack will be added as I progress)*

## üõ†Ô∏è Environment & Tools

- **Language:** Java 17+
- **IDE:** IntelliJ IDEA
- **Methodology:**
    1. Understand the problem and constraints.
    2. Visualize the solution (drawing/logic).
    3. Brute force approach (if applicable).
    4. Optimized approach (focusing on Big O).
    5. Implementation & Testing.

## üìù Key Concepts & Notes

My personal notes on the logic behind these solutions, including "why" a specific data structure was chosen, are documented in my personal knowledge base (Obsidian).

Key patterns practiced in this repo:
- **Hash Maps** for constant time lookups.
- **Two Pointers** for sorted arrays.
- **Sliding Window** for subarrays/substrings.
- **Fast & Slow Pointers** for linked list cycles.

## ü§ù Connect

Feel free to reach out if you have any questions about the solutions!

---
*Created by [Seu Nome]*